0
00:00:00,000 --> 00:00:02,670
모듈 1의 코딩 activity에 대해

1
00:00:02,670 --> 00:00:04,860
설명드리겠습니다

2
00:00:04,860 --> 00:00:08,670
after G 라는 프로그램을 만들게 될겁니다

3
00:00:08,670 --> 00:00:12,840
after G는 단어들을 입력하면 단어들이 추가되고

4
00:00:12,840 --> 00:00:16,770
그중 처음 시작하는 글자가 알파벳 G보다 뒤에 있는 단어들을

5
00:00:16,770 --> 00:00:20,970
모아 결과로 출력해주는 프로그램입니다

6
00:00:20,970 --> 00:00:25,260
이 페이지에서 필수적인 요구사항에 대해

7
00:00:25,260 --> 00:00:30,815
조금 더 이야기해 봅시다.

8
00:00:30,815 --> 00:00:32,400
이 과정에서는 반드시

9
00:00:32,400 --> 00:00:35,805
사용해야 하는 특정 키워드가 있습니다.

10
00:00:35,805 --> 00:00:37,290
이것들을 사용하지 않으면

11
00:00:37,290 --> 00:00:39,510
솔루션 코드를 제출할 때

12
00:00:39,510 --> 00:00:42,180
크레딧을 받을 수 없습니다.

13
00:00:42,180 --> 00:00:44,175
그래서 우선,

14
00:00:44,175 --> 00:00:46,680
G보다 큰(아스키코드상)

15
00:00:46,680 --> 00:00:48,390
문자들을 출력할 겁니다

16
00:00:48,390 --> 00:00:51,270
print() 함수를 사용해야하고요,

17
00:00:51,270 --> 00:00:52,825
input() 을 써서 입력을

18
00:00:52,825 --> 00:00:55,592
받을겁니다. 그 중 일부를 

19
00:00:55,592 --> 00:00:57,315
걸러내야겠죠?

20
00:00:57,315 --> 00:01:00,205
몇가지 과정을  

21
00:01:00,205 --> 00:01:02,535
반복하기 위해

22
00:01:02,535 --> 00:01:06,660
for / in 키워드도

23
00:01:06,660 --> 00:01:11,010
사용해줄겁니다. 그리고 반복문 내에서 isalpha를 이용해서

24
00:01:11,010 --> 00:01:14,235
모두 알파벳인지 확인해줄겁니다

25
00:01:14,235 --> 00:01:16,425
만약 모두 알파벳 문자라면

26
00:01:16,425 --> 00:01:18,655
조건 분기를 만들 수 있습니다. 그렇죠?

27
00:01:18,655 --> 00:01:22,545
isalpha를 if와 else 같이 사용할 겁니다

28
00:01:22,545 --> 00:01:27,395
혹은 elif와도 사용할 수 있죠

29
00:01:27,395 --> 00:01:29,610
그리고나서

30
00:01:29,610 --> 00:01:31,170
upper() 나 lower()을 같이써줘야합니다

31
00:01:31,170 --> 00:01:32,580
왜냐하면 문자열을 비교할 것이기 때문입니다

32
00:01:32,580 --> 00:01:35,040
확실하게 하고 싶다면 

33
00:01:35,040 --> 00:01:36,840
isupper나 islower를 사용해서

34
00:01:36,840 --> 00:01:38,730
검사할 수도 있습니다

35
00:01:38,730 --> 00:01:42,300
EdX 페이지를 살펴 보겠습니다.

36
00:01:42,300 --> 00:01:44,205
여기에 저희가 

37
00:01:44,205 --> 00:01:46,800
해야할 일에 대한

38
00:01:46,800 --> 00:01:48,420
더 자세한 설명과

39
00:01:48,420 --> 00:01:52,110
어떤 기능을 구축해야하는지 보여주는

40
00:01:52,110 --> 00:01:56,030
순서도를 살펴보겠습니다

41
00:01:56,030 --> 00:02:01,585
자 jupyter 노트북을 먼저 살펴 보겠습니다.

42
00:02:01,585 --> 00:02:06,497
EdX 페이지와 동일한 내용이 적혀있습니다

43
00:02:06,497 --> 00:02:10,230
저는 이전에 코드를 올려놨습니다

44
00:02:10,230 --> 00:02:13,130
어떻게 작동하는지 봅시다.

45
00:02:13,130 --> 00:02:16,860
프로그램은 문장을 입력하도록 요구합니다.

46
00:02:16,860 --> 00:02:18,500
그래서 여러분이 알만한

47
00:02:18,500 --> 00:02:21,395
명언을 넣겠씁니다

48
00:02:21,395 --> 00:02:23,525
"어디를 가든지 온 마음을 다해 가라(공자)"

49
00:02:23,525 --> 00:02:26,225
그리고 엔터를 치면, 결과를 볼 수 있습니다

50
00:02:26,225 --> 00:02:28,280
알파벳 G보다 큰

51
00:02:28,280 --> 00:02:30,440
첫글자를 가지는

52
00:02:30,440 --> 00:02:36,185
H...I...J..K 등등 

53
00:02:36,185 --> 00:02:38,805
문자들을 가지는 단어만 출력됩니다

54
00:02:38,805 --> 00:02:43,290
플로우 차트를 보도록하겠습니다.

55
00:02:43,290 --> 00:02:50,561
입력을 받고,

56
00:02:50,561 --> 00:02:52,800
문자열 내의 모든 문자에 대해

57
00:02:52,800 --> 00:02:55,640
반복합니다

58
00:02:55,640 --> 00:02:57,420
그리고 모두다 알파벳 문자인지

59
00:02:57,420 --> 00:02:59,490
확인합니다

60
00:02:59,490 --> 00:03:02,660
그래서, 입력했던 첫번째 단어를 한번

61
00:03:02,660 --> 00:03:11,180
보겠습니다

62
00:03:11,380 --> 00:03:17,475
첫번째 문자가 w로 시작하고

63
00:03:17,475 --> 00:03:21,620
알파벳 문자가 맞네요

64
00:03:21,620 --> 00:03:23,060
그래서 이걸 단어에 추가할겁니다

65
00:03:23,060 --> 00:03:31,543
기본적으로 단어와 문자열은 같습니다

66
00:03:31,543 --> 00:03:33,245
그래서 W로 시작한 다음 루프를

67
00:03:33,245 --> 00:03:36,790
계속 진행하면서

68
00:03:36,790 --> 00:03:38,950
문자열의

69
00:03:38,950 --> 00:03:42,837
각 문자를 얻으려고

70
00:03:42,837 --> 00:03:44,050
계속 문자열에서 문자를 추출합니다

71
00:03:44,050 --> 00:03:46,165
그러면 W가 끝나면 H로 갑니다.

72
00:03:46,165 --> 00:03:49,900
그리고 계속 돌면서

73
00:03:49,900 --> 00:03:53,928
ereever 순으로 진행됩니다

74
00:03:53,928 --> 00:03:56,975
그리고 공백문자가 들어옵니다

75
00:03:56,975 --> 00:03:58,990
공백문자가 오면

76
00:03:58,990 --> 00:04:01,330
단어에 추가되지 않습니다

77
00:04:01,330 --> 00:04:02,425


78
00:04:02,425 --> 00:04:05,122
왜냐하면 알파벳 문자가 아니기 때문입니다

79
00:04:05,122 --> 00:04:06,595
그래서 우리가 할일은

80
00:04:06,595 --> 00:04:09,030
입력한 단어를 확인하는 겁니다

81
00:04:09,030 --> 00:04:10,360
그래서

82
00:04:10,360 --> 00:04:12,605
단어를 입력하고

83
00:04:12,605 --> 00:04:14,005
첫번째 문자를 확인해서

84
00:04:14,005 --> 00:04:16,790
H랑 같거나 크면

85
00:04:16,790 --> 00:04:18,070
확실하게 하기 위해

86
00:04:18,070 --> 00:04:21,475
대문자나 소문자로 바꿀것이고

87
00:04:21,475 --> 00:04:23,725
그다음 그 단어를 출력할겁니다

88
00:04:23,725 --> 00:04:25,180
그리고 단어 변수에 빈 문자열을 넣어서

89
00:04:25,180 --> 00:04:27,270
초기화해준다음에, 거기 있는 문자들에

90
00:04:27,270 --> 00:04:29,080
대해서 똑같은 방식으로 처리해줄겁니다

91
00:04:29,080 --> 00:04:31,780
다음에는 you라는 단어를 처리할거고

92
00:04:31,780 --> 00:04:35,305
공백문자가 들어왔을때

93
00:04:35,305 --> 00:04:40,875
출력 해줄겁니다. 왜냐하면

94
00:04:40,875 --> 00:04:44,860
G보다 큰 문자로 시작하기 때문입니다, 그리고 go의 경우 

95
00:04:44,860 --> 00:04:49,136
go 라는 단어들이 들어올때, 

96
00:04:49,136 --> 00:04:51,772
대문자로 바꿔주지 않을겁니다


97
00:04:51,772 --> 00:04:54,495
왜냐하면 여기서 이쪽으로 가서

98
00:04:54,495 --> 00:04:59,395
단어를 확인할 것이기 때문이죠

99
00:04:59,395 --> 00:05:04,013
그리고 나서 빈 문자열로 만드는 분기로 바로 이동하게 됩니다

100
00:05:04,013 --> 00:05:06,690
그래서 아마 여러분이 작성하는 솔루션 코드에는

101
00:05:06,690 --> 00:05:09,565
단어 변수를 빈 문자열로 만들어주는 코드를 2번 넣어줘야할 겁니다

102
00:05:09,565 --> 00:05:10,950
아니면 출력만 하지 않고

103
00:05:10,950 --> 00:05:13,320
문자열을 비우는 방법도 있겠네요

104
00:05:13,320 --> 00:05:14,420
하지만 그렇게 하지 마세요

105
00:05:14,420 --> 00:05:16,050


106
00:05:16,050 --> 00:05:17,865
그래서, go 들을

107
00:05:17,865 --> 00:05:19,893
출력하지 않고, 그 다음 단어들을

108
00:05:19,893 --> 00:05:22,500
계속 이런 방식으로 처리합니다

109
00:05:22,500 --> 00:05:24,618
문자열의 끝에 도착하면

110
00:05:24,618 --> 00:05:26,825
더 이상 처리할 문자가 없습니다

111
00:05:26,825 --> 00:05:30,905
더 이상 남은 문자가 없다면 프로그램을 종료합니다

112
00:05:30,905 --> 00:05:33,810
자, 문자열을 어떻게 입력했느냐에 따라

113
00:05:33,810 --> 00:05:40,358
비교를 하고,

114
00:05:40,358 --> 00:05:44,030
단어를 확인해서

115
00:05:44,030 --> 00:05:46,650
알파벳 문자로 이루어 진게 아니라면

116
00:05:46,650 --> 00:05:48,820
이쪽으로 가고,

117
00:05:48,820 --> 00:05:51,393
그렇지 않다면 

118
00:05:51,393 --> 00:05:53,359
다음 비교를 진행할 겁니다

119
00:05:53,359 --> 00:05:55,560
똑같이 말이죠

120
00:05:55,560 --> 00:05:58,690
그리고 이쪽으로 가도록 만들어야할겁니다

121
00:05:58,690 --> 00:06:00,720
그래서 여러분은 어떻게 해야

122
00:06:00,720 --> 00:06:03,220
문자열이 끝나서 이쪽으로 갈건지

123
00:06:03,220 --> 00:06:08,070
어떤식으로 체크해야하는지를 결정해야할 겁니다

124
00:06:08,070 --> 00:06:10,153
진행하면서 논리적으로 잘 작동하게 만들어보세요

125
00:06:10,153 --> 00:06:14,290
마지막 단어가 출력되지 않았다면

126
00:06:14,290 --> 00:06:17,236
아마 올바르게 짰을겁니다

127
00:06:17,236 --> 00:06:18,995
왜냐하면 더이상 공간이 없기 때문이죠.

128
00:06:18,995 --> 00:06:21,280
이쪽으로 가지도 않을거고, 단어도 안들어올겁니다

129
00:06:21,280 --> 00:06:23,050
그래서 프로그램을 돌릴때

130
00:06:23,050 --> 00:06:26,095
이 비디오로 되돌아와서

131
00:06:26,095 --> 00:06:28,350
"이거 왜 안되요?" 라고 할수도 있습니다

132
00:06:28,350 --> 00:06:31,180
왜냐하면 종료될려면 뒤에 공백이 필요하기 때문입니다

133
00:06:31,180 --> 00:06:35,262
그래서 여러분이 이 부분을 프로그래머 로서 해결해야합니다

134
00:06:35,262 --> 00:06:38,985
코드를 제출하는 방법을 살펴 보겠습니다.

135
00:06:38,985 --> 00:06:41,200
EdX에 가면, 여러분은

136
00:06:41,200 --> 00:06:42,985
이 탭을 볼 수 있습니다

137
00:06:42,985 --> 00:06:45,310
그리고 나서 숙제 칸으로 가서

138
00:06:45,310 --> 00:06:47,770
제출란으로 가세요

139
00:06:47,770 --> 00:06:49,810
그리고 코드를 제출할 때,

140
00:06:49,810 --> 00:06:53,590
제출 칸에 코드를 넣어도

141
00:06:53,590 --> 00:06:55,390
여러분이 코드를 붙여넣어도 코드에 들어가는 들여쓰기나 줄바꿈같은

142
00:06:55,390 --> 00:06:57,845
형식들은 보이지 않습니다

143
00:06:57,845 --> 00:07:01,510
그래서 여러분이 해야 할 일은 여러분의 notebook에 들어가서

144
00:07:01,510 --> 00:07:03,160
여러분이 셀에 

145
00:07:03,160 --> 00:07:06,640
작성한 전체 솔루션 코드를

146
00:07:06,640 --> 00:07:09,193
복사한 다음에

147
00:07:09,193 --> 00:07:11,505
복사한 다음에...

148
00:07:11,505 --> 00:07:12,940
그 다음에 이 탭으로 돌아와서

149
00:07:12,940 --> 00:07:15,610
여기에 붙여 넣습니다

150
00:07:15,610 --> 00:07:19,105
Windows에서는 Ctrl C, Ctrl V입니다.

151
00:07:19,105 --> 00:07:20,389
그래서 탭에

152
00:07:20,389 --> 00:07:22,390
여러분이 notebook에서 복사해온 코드를

153
00:07:22,390 --> 00:07:24,693
edx에 붙여넣으세요

154
00:07:24,693 --> 00:07:27,070
그리고 제출하면

155
00:07:27,070 --> 00:07:29,230
칸이 녹색으로

156
00:07:29,230 --> 00:07:31,455
표시됩니다

157
00:07:31,455 --> 00:07:33,870
그리고 보면 2번 중 1도 시도했다는걸 표시해주고

158
00:07:33,870 --> 00:07:35,110
시도했는데 빨간새그로

159
00:07:35,110 --> 00:07:36,840
표시됐다면

160
00:07:36,840 --> 00:07:38,673
각각의 키워드를

161
00:07:38,673 --> 00:07:41,560
사용했었는지 

162
00:07:41,560 --> 00:07:45,229
확인하고,

163
00:07:45,229 --> 00:07:47,658
그리고 잘 작동하는지 확인해보세요

164
00:07:47,658 --> 00:07:49,790
좋습니다, 즐거운 코딩 되시길 바랍니다

